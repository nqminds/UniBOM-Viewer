import fs from "fs";
import readline from "readline";
import { fileURLToPath } from "url";
import path from "node:path";
import { dirname } from "path";
import { createCPEMapping } from "./utils.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Returns a list of cpes for each edpendency
 *
 * @param {string} conanfilePath - path to conanfile.txt
 * @param {string} projectName - name of your project
 */
export async function processDependencies(conanfilePath, projectName) {
  const csvFilePath = path.resolve(__dirname, "../input/cpe_data.csv");
  // the file can become quite large so use ReadStream to reduce memory usage
  const fileStream = fs.createReadStream(conanfilePath);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity,
  });

  const dependencies = [];
  let isRequiresSection = false;

  for await (const line of rl) {
    if (line.startsWith("[requires]")) {
      isRequiresSection = true;
    } else if (line.startsWith("[")) {
      isRequiresSection = false;
    } else if (isRequiresSection) {
      let dependency = line.replace("/", ":");
      dependency = dependency.replace(/'/g, "");
      if (dependency) {
        // check that the string is not empty after trimming
        dependencies.push(dependency);
      }
    }
  }

  const cpeMapping = await createCPEMapping(csvFilePath, dependencies);
  const dirPath = path.resolve(__dirname, `../input/cpes/${projectName}`);
  const cpeFilePath = path.join(dirPath, "cpeMapping.json");

  try {
    fs.mkdirSync(dirPath, { recursive: true }); // create directory if dosen't exist
    fs.writeFileSync(cpeFilePath, JSON.stringify(cpeMapping, null, 2));
  } catch (error) {
    throw new Error(` Error trying writing cpe mapping file:  ${error}`);
  }
}
