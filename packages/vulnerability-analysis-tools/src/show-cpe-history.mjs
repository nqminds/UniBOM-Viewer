/* eslint-disable no-await-in-loop */
/* eslint-disable no-console */
/* eslint-disable promise/prefer-await-to-then */
import fs from "fs";
import csvParser from "csv-parser";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { cleanCpe } from "./get-syft-cpes.mjs";
import { fetchCVEsForCPE } from "./list-vulnerabilities.mjs";
import { classifyCwe } from "./classify_cwe.mjs";
import { previousCpeVersion } from "./utils.mjs";
import {
  initialiseCveDatabase,
  insertOrUpdateCVEData,
  getCVEData,
} from "./cve_database.mjs";
import { makeClassificationRequest } from "./classify_cve.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const databaseDir = path.join(__dirname, "../data");
const databasePath = path.join(databaseDir, "cached_cves.db");

if (!fs.existsSync(databaseDir)) {
  fs.mkdirSync(databaseDir, { recursive: true });
}

/**
 * Search the cpe_data.csv for a list of all known versions of a cpe
 *
 * @param {string} cpe - cpe
 * @returns {string[]} - Returns all previous/later releases of a cpe
 */
export async function mapHistoricalCpes(cpe) {
  const cpeDataPath = path.resolve(
    __dirname,
    "../vulnerability-reports/cpe_data.csv"
  );
  const cpeParts = cpe.split(":");

  const cpeVersions = {};
  cpeVersions[cpe] = [];

  return new Promise((resolve, reject) => {
    const vendor = cpeParts[3];
    const product = cpeParts[4];

    fs.createReadStream(cpeDataPath)
      .pipe(csvParser())
      .on("data", (row) => {
        const cpeName = row.cpe_name;

        if (
          cpeName &&
          cpeName.includes(`:${vendor}:`) &&
          cpeName.includes(`:${product}:`)
        ) {
          // Check if the CPE from the row is a previous version of the input CPE
          if (previousCpeVersion(cpe, cpeName)) {
            cpeVersions[cpe].push(cpeName);
          }
        }
      })
      .on("end", () => resolve(cpeVersions))
      .on("error", (error) => reject(error));
  });
}

/**
 * Function to find historical CPEs and their weaknesses
 *
 * @param {string} cpe - CPE
 * @param {boolean} includeHistoricalCpes - boolean to indicate if to include all historical versions
 * @returns {string[]} - Promises CPE-CVE-CWE-Type
 */
export async function mapCpeCveCwe(cpe, includeHistoricalCpes = true) {
  const cpeCveMap = [];
  const allPromises = [];
  const cpe_23 = cleanCpe(cpe);
  let cpeVersions = {};

  if (includeHistoricalCpes) {
    cpeVersions = await mapHistoricalCpes(cpe_23);
  } else {
    cpeVersions[cpe_23] = [cpe_23];
  }

  for (const key in cpeVersions) {
    for (const element of cpeVersions[key]) {
      const cpe23 = cleanCpe(element);

      const promise = fetchCVEsForCPE(cpe23).then(async (cves) => {
        const innerPromises = [];
        if (cves && cves.length > 0) {
          for (const vulnerability of cves) {
            const cveId = vulnerability.id || "N/A";
            const cweWeakness = Array.isArray(vulnerability.weakness)
              ? vulnerability.weakness
              : vulnerability.weakness
              ? [vulnerability.weakness]
              : ["N/A"];

            const classifications = [];

            for (const cwe of cweWeakness) {
              let classification = "No info";
              const cweExists = await classifyCwe(cwe);
              if (
                cwe === "NVD-CWE-noinfo" ||
                cwe === "No info" ||
                cwe === "NVD-CWE-Other" ||
                cweExists === null
              ) {
                await initialiseCveDatabase(databasePath);
                const cveInfo = await getCVEData(
                  vulnerability.id,
                  databasePath
                );
                if (!cveInfo) {
                  classification = await makeClassificationRequest(
                    vulnerability.description
                  );
                  if (typeof classification === "string") {
                    await insertOrUpdateCVEData(
                      vulnerability.id,
                      vulnerability.description,
                      classification,
                      databasePath
                    );
                  } else {
                    classification = "No info";
                  }
                } else {
                  classification = cveInfo.classification;
                }
              }
              const validClassification =
                typeof classification === "string" ? classification : "No info";
              const innerPromise = classifyCwe(cwe).then((weakType) => {
                classifications.push(weakType || validClassification);
              });
              innerPromises.push(innerPromise);
            }

            await Promise.all(innerPromises);

            cpeCveMap.push({
              cpe: element,
              cve: cveId,
              cwe: cweWeakness,
              weakType: classifications,
            });
          }
        } else {
          cpeCveMap.push({
            cpe: element,
            cve: "CVE No Info",
            cwe: ["CWE No Info"],
            weakType: ["Type No Info"],
          });
        }
      });

      allPromises.push(promise);
    }
  }

  await Promise.all(allPromises);
  return cpeCveMap;
}

/**
 * Function to find historical CPEs and their weaknesses
 *
 * @param {string} cpe - CPE
 * @param {string} openaiApiKey - OpenAi API key
 * @returns {string[]} - yeld CPE-CVE-CWE-Type
 */
export async function* streamMapCpeCveCwe(cpe, openaiApiKey) {
  const cpe_23 = cleanCpe(cpe);
  const cpeVersions = await mapHistoricalCpes(cpe_23);
  let processedCount = 0;

  // Calculate the total number of CPEs to be processed
  const totalCPEs = Object.values(cpeVersions).reduce(
    (total, versions) => total + versions.length,
    0
  );

  // Emit the total count of CPEs
  yield { type: "total", total: totalCPEs };
  let entry;
  for (const key in cpeVersions) {
    for (const element of cpeVersions[key]) {
      const cpe23 = cleanCpe(element);
      const cves = await fetchCVEsForCPE(cpe23);
      processedCount = ++processedCount;
      if (!cves || cves.length === 0) {
        entry = {
          cve: "None",
          cwe: ["None"],
          weakType: "No Info",
          baseScore: 0,
          baseSeverity: "None",
        };
        yield { cpe: element, data: entry, processed: processedCount };
        continue;
      }

      for (const vulnerability of cves) {
        const cveId = vulnerability.id || "N/A";
        const baseScore = vulnerability.baseScore;
        const baseSeverity = vulnerability.baseSeverity;
        const cweWeakness = Array.isArray(vulnerability.weakness)
          ? vulnerability.weakness
          : [vulnerability.weakness || "N/A"];
        let weakType = await classifyCwe(cweWeakness[0]);
        if (!weakType) {
          await initialiseCveDatabase(databasePath);
          const cveInfo = await getCVEData(cveId, databasePath);
          if (!cveInfo) {
            weakType = await makeClassificationRequest(
              vulnerability.description,
              openaiApiKey
            );
            if (typeof weakType === "string" && weakType !== "Unknown") {
              await insertOrUpdateCVEData(
                vulnerability.id,
                vulnerability.description,
                weakType,
                databasePath
              );
            } else {
              weakType = "Unknown";
            }
          } else {
            weakType = cveInfo.classification;
          }
        }
        entry = {
          cve: cveId,
          cwe: cweWeakness,
          weakType: weakType,
          baseScore: baseScore,
          baseSeverity: baseSeverity,
        };
        yield { cpe: element, data: entry, processed: processedCount };
      }
    }
  }
}
