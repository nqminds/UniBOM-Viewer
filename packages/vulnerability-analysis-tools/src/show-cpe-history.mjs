/* eslint-disable no-await-in-loop */
/* eslint-disable no-console */
/* eslint-disable promise/prefer-await-to-then */
import fs from "fs";
import csvParser from "csv-parser";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { cleanCpe } from "./get-syft-cpes.mjs";
import { fetchCVEsForCPE } from "./list-vulnerabilities.mjs";
import { classifyCwe } from "./classify_cwe.mjs";
import { previousCpeVersion } from "./utils.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Search the cpe_data.csv for a list of all known versions of a cpe
 *
 * @param {string} cpe - cpe
 * @returns {string[]} - Returns all previous/later releases of a cpe
 */
export async function mapHistoricalCpes(cpe) {
  const cpeDataPath = path.resolve(
    __dirname,
    "../vulnerability-reports/cpe_data.csv"
  );
  const cpeParts = cpe.split(":");

  const cpeVersions = {};
  cpeVersions[cpe] = [];

  return new Promise((resolve, reject) => {
    const vendor = cpeParts[3];
    const product = cpeParts[4];

    fs.createReadStream(cpeDataPath)
      .pipe(csvParser())
      .on("data", (row) => {
        const cpeName = row.cpe_name;

        if (
          cpeName &&
          cpeName.includes(`:${vendor}:`) &&
          cpeName.includes(`:${product}:`)
        ) {
          // Check if the CPE from the row is a previous version of the input CPE
          if (previousCpeVersion(cpe, cpeName)) {
            cpeVersions[cpe].push(cpeName);
          }
        }
      })
      .on("end", () => resolve(cpeVersions))
      .on("error", (error) => reject(error));
  });
}

/**
 * Function to find historical CPEs and their weaknesses
 *
 * @param {string} cpe - CPE
 * @returns {string[]} - Promises CPE-CVE-CWE-Type
 */
export async function mapCpeCveCwe(cpe) {
  const cpeCveMap = {}; // Use an object instead of an array
  const allPromises = [];
  const cpe_23 = cleanCpe(cpe);
  const cpeVersions = await mapHistoricalCpes(cpe_23);

  for (const key in cpeVersions) {
    for (const element of cpeVersions[key]) {
      const cpe23 = cleanCpe(element);
      if (!cpeCveMap[element]) {
        cpeCveMap[element] = []; // Initialize the array for this CPE
      }

      const promise = fetchCVEsForCPE(cpe23).then((cves) => {
        const innerPromises = cves.map((vulnerability) => {
          const cveId = vulnerability.id || "N/A";
          const baseScore = vulnerability.baseScore;
          const baseSeverity = vulnerability.baseSeverity;
          const cweWeakness = Array.isArray(vulnerability.weakness)
            ? vulnerability.weakness
            : [vulnerability.weakness || "N/A"];

          return classifyCwe(cweWeakness[0]).then((weakType) => {
            cpeCveMap[element].push({
              cve: cveId,
              cwe: cweWeakness,
              weakType: weakType || "No Info",
              baseScore: baseScore,
              baseSeverity: baseSeverity,
            });
          });
        });

        return Promise.all(innerPromises);
      });

      allPromises.push(promise);
    }
  }

  await Promise.all(allPromises);
  return cpeCveMap;
}

/**
 * Function to find historical CPEs and their weaknesses
 *
 * @param {string} cpe - CPE
 * @returns {string[]} - yeld CPE-CVE-CWE-Type
 */
export async function* streamMapCpeCveCwe(cpe) {
  const cpe_23 = cleanCpe(cpe);
  const cpeVersions = await mapHistoricalCpes(cpe_23);
  let entry;
  for (const key in cpeVersions) {
    for (const element of cpeVersions[key]) {
      const cpe23 = cleanCpe(element);
      const cves = await fetchCVEsForCPE(cpe23);
      if (!cves || cves.length === 0) {
        entry = {
          cve: "None",
          cwe: ["None"],
          weakType: "No Info",
          baseScore: 0,
          baseSeverity: "None",
        };
        yield { cpe: element, data: entry };
        continue;
      }

      for (const vulnerability of cves) {
        const cveId = vulnerability.id || "N/A";
        const baseScore = vulnerability.baseScore;
        const baseSeverity = vulnerability.baseSeverity;
        const cweWeakness = Array.isArray(vulnerability.weakness)
          ? vulnerability.weakness
          : [vulnerability.weakness || "N/A"];

        const weakType = (await classifyCwe(cweWeakness[0])) || "No Info";
        entry = {
          cve: cveId,
          cwe: cweWeakness,
          weakType: weakType || "No Info",
          baseScore: baseScore,
          baseSeverity: baseSeverity,
        };
        yield { cpe: element, data: entry };
      }
    }
  }
}
