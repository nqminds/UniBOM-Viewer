import fs from "fs";
import { fileURLToPath } from "url";
import path from "node:path";
import { dirname } from "path";
import { create } from "xmlbuilder2";
import { createCPEMapping, processDependencies } from "./utils.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// create a dummy SBOM file
function createCycloneDxSBOM(cpeMapping) {
  const bom = create({ version: "1.0" })
    .ele("bom", { xmlns: "http://cyclonedx.org/schema/bom/1.2", version: "1" })
    .ele("components");

  Object.keys(cpeMapping).forEach((dep) => {
    const cpeNames = cpeMapping[dep];
    cpeNames.forEach((cpe) => {
      const parts = cpe.split(":");
      const version = parts[4];
      bom
        .ele("component", { type: "library" })
        .ele("name")
        .txt(dep)
        .up()
        .ele("version")
        .txt(version)
        .up()
        .ele("cpe")
        .txt(cpe)
        .up();
    });
  });

  return bom.end({ prettyPrint: true });
}

/**
 * Returns a bom from a list of dependencies
 *
 * @param {string} projectName - name of your project
 */
export async function generateDummySBOM(projectName) {
  try {
    const conanFilePath = path.resolve(
      __dirname,
      `../input/conan-files/${projectName}/conanfile.txt`
    );
    const csvFilePath = path.resolve(__dirname, "../input/cpe_data.csv");
    const dependencies = await processDependencies(conanFilePath);
    const cpeMapping = await createCPEMapping(csvFilePath, dependencies);
    const cycloneDxSBOM = createCycloneDxSBOM(cpeMapping);
    const dirPath = path.resolve(__dirname, `../input/cpes/${projectName}`);
    const sbomFilePath = path.join(dirPath, "bom.xml");

    fs.mkdirSync(dirPath, { recursive: true }); // create directory if dosen't exist
    fs.writeFileSync(sbomFilePath, cycloneDxSBOM);
  } catch (error) {
    throw new Error(
      `Error trying writing CycloneDX SBOM file: ${error.message}`
    );
  }
}
