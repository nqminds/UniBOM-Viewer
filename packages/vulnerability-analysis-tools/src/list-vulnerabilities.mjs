/* eslint-disable promise/catch-or-return */
/* eslint-disable no-console */
import { fileURLToPath } from "url";
import PQueue from "p-queue";
import { promises as fs } from "fs";
import { getCpes } from "./identify-cpe.mjs";
import axios from "axios";
// import config from '../config/config.json' assert {type: 'json'};
import path from "node:path";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// TODO: Fix Enlist Unexpected token assert for config
// const apiKey = config.get("apiKey");
const apiKey = "a03cfee3-bcf1-4f6d-ac31-fe9f7bda1bb2";

const baseUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";
export const cveData = {};
const previousResponses = [];
const headers = {};
const queue = new PQueue({ concurrency: 1 });

if (apiKey) {
  headers.apiKey = apiKey;
}

// Function to delay the api requests
function delay(ms) {
  // eslint-disable-next-line no-promise-executor-return
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Function to fetch CVEs for a single CPE
async function fetchCVEsForCPE(cpeName) {
  const formattedUrl = `${baseUrl}?cpeName=cpe:2.3:${cpeName}`;
  try {
    const response = await axios.get(formattedUrl, {
      headers,
    });
    const cves = response.data.vulnerabilities.map(
      (vulnerability) => vulnerability.cve.id
    );
    cveData[cpeName] = cves;

    // Store the response in the previousResponses array
    previousResponses.push({ cpeName, cves });
  } catch (error) {
    throw new Error(`Error for ${cpeName}:`, error);
  }
  // have a delay of 6 seconds between requests due to api restrictions
  await delay(6000);
}

/**
 * Function to control the rate of API requests.
 *
 * @returns {string[]} Array of  CVEs.
 */
export async function fetchCVEsWithRateLimit() {
  const cpes = await getCpes();
  // Add all API requests to the queue
  await Promise.all(
    cpes.map((cpeName) => queue.add(() => fetchCVEsForCPE(cpeName)))
  );

  // Wait for all requests in the queue to complete
  await queue.onIdle();

  return cveData;
}

// Call the function to fetch CVEs with rate limiting
fetchCVEsWithRateLimit().then(async () => {
  // After all requests are completed, save cveData to a JSON file
  const jsonContent = JSON.stringify(cveData, null, 2);
  try {
    await fs.writeFile(
      path.resolve(__dirname, "../input/cveData.json"),
      jsonContent
    );
  } catch (err) {
    throw new Error(`Error saving cveData to file: ${err.message}`);
  }
});
