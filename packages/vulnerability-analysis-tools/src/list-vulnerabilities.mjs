import { fileURLToPath } from "url";
import PQueue from "p-queue";
import { promises as fs } from "fs";
import { getCpes } from "./get-syft-cpes.mjs";
import axios from "axios";
import path from "node:path";
import { dirname } from "path";
import Bottleneck from "bottleneck";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configContent = await fs.readFile(
  path.join(__dirname, "../config/config.json")
);
const config = JSON.parse(configContent);
const apiKey = config.apiKey;
const baseUrl = config.cveBaseUrl;
export const cveData = {};
const previousResponses = [];
const headers = {};
const queue = new PQueue({ concurrency: 1 });

if (apiKey) {
  headers.apiKey = apiKey;
}

// 30000ms / 50ms = 600ms, 50 requests per 30 second = 1 request per 600ms
const limiter = new Bottleneck({
  minTime: 600,
  maxConcurrent: 1,
});

/**
 *Function to fetch CVEs for a single CPE
 *
 * @param {string} cpeName - The base CPE name eg: cpe:2.3:a:busybox:busybox:0.60.0:*:*:*:*:*:*:*.
 * @returns {object[]} - For each CPE returns an array of CVEs. {"cpe": [{CVE}, {CVE} ... ]}
 */
export async function fetchCVEsForCPE(cpeName) {
  const formattedUrl = `${baseUrl}?cpeName=${cpeName}`;
  try {
    const response = await limiter.schedule(() =>
      axios.get(formattedUrl, { headers })
    );
    // more data can be added here as needed
    const cves = response.data.vulnerabilities.map((vulnerability) => {
      const weaknesses = vulnerability.cve.weaknesses?.map((weakness) => {
        return (
          weakness.description?.find((desc) => desc.lang === "en")?.value ||
          "N/A"
        );
      });
      return {
        id: vulnerability.cve.id,
        description:
          vulnerability.cve.descriptions?.find((desc) => desc.lang === "en")
            ?.value || "N/A",
        weakness: weaknesses,
      };
    });
    cveData[cpeName] = cves;
    // Store the response in the previousResponses array
    previousResponses.push({ cpeName, cves });
    return cves;
  } catch (error) {
    throw new Error(`Error for ${cpeName}:`, error);
  }
}

/**
 * Function to control the rate of API requests.
 *
 * @param {string|object} sbomPath - Path to sbomFile or json object
 *
 * @returns {string[]} Array of  CVEs.
 */
export async function fetchCVEsWithRateLimit(sbomPath) {
  try {
    const cpes = await getCpes(sbomPath);
    // Add all API requests to the queue
    await Promise.all(
      cpes.map((cpeName) => queue.add(() => fetchCVEsForCPE(cpeName)))
    );
    // Wait for all requests in the queue to complete
    await queue.onIdle();
  } catch (error) {
    throw new Error(`Error: ${Error.message}`);
  }
  return cveData;
}

/**
 * Function to write cve data to file.
 *
 * @param {string|object} sbomPath - Path to sbomFile or json object
 *
 */
export async function writeCvesToFile(sbomPath) {
  // Call the function to fetch CVEs with rate limiting
  const cveJsonData = await fetchCVEsWithRateLimit(sbomPath);
  // After all requests are completed, save cveData to a JSON file
  const jsonContent = JSON.stringify(cveJsonData, null, 2);

  try {
    await fs.writeFile(
      path.resolve(__dirname, "../input/cveData.json"),
      jsonContent
    );
  } catch (err) {
    throw new Error(`Error saving cveData to file: ${err.message}`);
  }
}
