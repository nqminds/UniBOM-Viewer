/* eslint-disable no-console */
import { fileURLToPath } from "url";
import PQueue from "p-queue";
import { promises as fsPromises } from "fs";
import { getCpes } from "./get-syft-cpes.mjs";
import axios from "axios";
import path from "node:path";
import { dirname } from "path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const configContent = await fsPromises.readFile(
  path.join(__dirname, "../config/config.json")
);
const config = JSON.parse(configContent);
const baseUrl = config.cveBaseUrl;
export const cveData = {};
const queue = new PQueue({ concurrency: 1 });

/**
 * Fetch CVEs for a single CPE.
 *
 * @param {string} cpeName - The CPE name, e.g., "cpe:2.3:a:busybox:busybox:0.60.0:*:*:*:*:*:*:*".
 * @param {string} apiEndpoint - API Endpoint
 * @returns {object[]} - An array of CVEs for the given CPE.
 */
export async function fetchCVEsForCPE(cpeName, apiEndpoint = baseUrl) {
  if (!cpeName) {
    console.error("CPE name is required");
    return null;
  }

  try {
    const response = await axios.post(apiEndpoint, { cpe: cpeName });

    if (response.status === 200 && response.data) {
      const { data, matches } = response.data;

      if (data && matches) {
        const cves = data.map((vulnerability) => {
          let description =
            vulnerability.cve_data.cve.description?.description_data?.find(
              (desc) => desc.lang === "en"
            )?.value || "Not Found";

          // Sanitize description to remove excessive newlines
          description = description.replace(/\n+/g, " ").trim();

          const weaknesses =
            vulnerability.cve_data.cve.problemtype?.problemtype_data?.map(
              (problem) =>
                problem.description?.find((desc) => desc.lang === "en")
                  ?.value || "Not Found"
            );

          const baseScore =
            vulnerability.cve_data.impact?.baseMetricV3?.cvssV3?.baseScore ||
            vulnerability.cve_data.impact?.baseMetricV2?.cvssV2?.baseScore ||
            "0";

          const baseSeverity =
            vulnerability.cve_data.impact?.baseMetricV3?.cvssV3?.baseSeverity ||
            vulnerability.cve_data.impact?.baseMetricV2?.severity ||
            "Unknown";

          return {
            id: vulnerability.cve_id,
            description,
            weakness: weaknesses,
            baseScore,
            baseSeverity,
          };
        });

        return cves;
      }
      // No CVE data returned for CPE
      return null;
    }
    console.error(
      `Failed to fetch CVEs: ${response.status} - ${response.statusText}`
    );
    return null;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      const status = error.response ? error.response.status : "Unknown";
      const statusText = error.response ? error.response.statusText : "Unknown";
      console.error(`AxiosError: ${status} - ${statusText}`);

      if (status === 404) {
        console.error(`The resource for ${cpeName} was not found.`);
      } else if (status === 401) {
        console.error("Unauthorized request. Please check your API key.");
      } else if (status === 500) {
        console.error("Server error. Try again later.");
      }
      return null;
    }

    console.error(`Unexpected error for ${cpeName}: ${error.message}`);
    return null;
  }
}

/**
 * Function to control the rate of API requests.
 *
 * @param {string|object} sbomPath - Path to sbomFile or json object
 * @param {string} nistApiKey - Nist API Key
 * @returns {string[]} Array of  CVEs.
 */
export async function fetchCVEsWithRateLimit(sbomPath, nistApiKey = "") {
  try {
    const cpes = await getCpes(sbomPath);
    // Add all API requests to the queue
    await Promise.all(
      cpes.map((cpeName) =>
        queue.add(() => fetchCVEsForCPE(cpeName, nistApiKey))
      )
    );
    // Wait for all requests in the queue to complete
    await queue.onIdle();
  } catch (error) {
    throw new Error(`Error: ${Error.message}`);
  }
  return cveData;
}

/**
 * Function to write cve data to file.
 *
 * @param {string|object} sbomPath - Path to sbomFile or json object
 * @param {string} outputPath - Absolute path to saved CveData
 *
 */
export async function writeCvesToFile(sbomPath, outputPath) {
  // Call the function to fetch CVEs with rate limiting
  const cveJsonData = await fetchCVEsWithRateLimit(sbomPath);
  // After all requests are completed, save cveData to a JSON file
  const jsonContent = JSON.stringify(cveJsonData, null, 2);

  try {
    await fsPromises.writeFile(
      path.resolve(__dirname, `${outputPath}/cveData.json`),
      jsonContent
    );
  } catch (err) {
    throw new Error(`Error saving cveData to file: ${err.message}`);
  }
}
