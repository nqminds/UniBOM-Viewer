/* eslint-disable no-console */
import dotenv from "dotenv";
import fs from "fs";
import csvParser from "csv-parser";
import readline from "readline";
import path from "path";
import { dirname } from "path";
import { fileURLToPath } from "url";
import { execFileSync } from "child_process";

/**
 * Mapps dependencies to cpes
 *
 *@param {string} filePath - csvFilepath
 *@param {string []} dependencies - dependencies
 */
export async function createCPEMapping(filePath, dependencies) {
  const cpeMapping = {};
  dependencies.forEach((dep) => (cpeMapping[dep] = []));

  return new Promise((resolve, reject) => {
    // use read stream to reduce memory usage.
    fs.createReadStream(filePath)
      .pipe(csvParser())
      .on("data", (row) => {
        const cpeName = row.cpe_name;
        dependencies.forEach((dep) => {
          let searchDep = dep;
          let version = "";

          if (dep.includes(":")) {
            [, version] = dep.split(":");
            searchDep = searchDep.replace(/:.*/, "");
          }
          if (
            cpeName &&
            cpeName.includes(`:${searchDep}:`) &&
            cpeName.includes(`:${version}`)
          ) {
            cpeMapping[dep].push(cpeName);
          }
        });
      })
      .on("end", () => resolve(cpeMapping))
      .on("error", (error) => reject(error));
  });
}

/**
 * Returns a list of dependencies
 *
 * @param {string} conanfilePath - path to conanfile.txt
 */
export async function processDependencies(conanfilePath) {
  // the file can become quite large so use ReadStream to reduce memory usage
  const fileStream = fs.createReadStream(conanfilePath);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity,
  });

  const dependencies = [];
  let isRequiresSection = false;

  for await (const line of rl) {
    if (line.startsWith("[requires]")) {
      isRequiresSection = true;
    } else if (line.startsWith("[")) {
      isRequiresSection = false;
    } else if (isRequiresSection) {
      let dependency = line.replace("/", ":");
      dependency = dependency.replace(/'/g, "");
      if (dependency) {
        // check that the string is not empty after trimming
        dependencies.push(dependency);
      }
    }
  }
  return dependencies;
}

/**
 * Returns the path to a targetFile
 *
 * @param {path} startDirectory - Path to the start dyrectory
 * @param {string} targetFile - Name of the file
 */
export async function findFileInSubdirectories(startDirectory, targetFile) {
  const recurseDir = async (dir) => {
    const filesAndDirectories = await fs.promises.readdir(dir, {
      withFileTypes: true,
    });

    const promises = filesAndDirectories.map(async (stat) => {
      if (stat.isDirectory()) {
        return recurseDir(path.join(dir, stat.name));
      } else if (stat.name === targetFile) {
        return path.join(dir, stat.name);
      }
      return null;
    });
    const results = await Promise.all(promises);
    for (const result of results) {
      if (result) return result;
    }
    return null;
  };
  return recurseDir(startDirectory);
}

/**
 * Get API Key from .env
 *
 * @returns {string} - ApiKey
 */
export function getApiKey() {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  dotenv.config({ path: path.resolve(__dirname, "../../../.env") });

  return process.env.NIST_API_KEY;
}

/**
 * Function to generate a Grype report
 *
 * @param {string} sbomFilePath - Path to sbom file
 * @param {string} projectName - Project name
 */
export async function genGrypeReport(sbomFilePath, projectName) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  const vulnerabilityReportFile = path.resolve(
    __dirname,
    `../vulnerability-reports/reports/vulnerability_report_${projectName}`
  );
  try {
    console.log("Running grype to generate vulnerability report...");
    const grypeArgs = [
      "run",
      "--rm",
      "-v",
      `${path.dirname(sbomFilePath)}:/vulnerability-reports`, // Mount the directory containing the SBOM file
      "anchore/grype",
      `/vulnerability-reports/${path.basename(sbomFilePath)}`, // Reference the SBOM file by its name inside the container
      "-o",
      "table",
    ];

    const tableOutput = execFileSync("docker", grypeArgs, {
      encoding: "utf-8",
      maxBuffer: 1024 * 5000,
    });

    fs.writeFileSync(vulnerabilityReportFile, tableOutput);

    console.log(tableOutput);
    console.log(`Vulnerability report saved to: ${vulnerabilityReportFile}`);
  } catch (error) {
    throw new Error(
      `Error generating vulnerability report for: ${vulnerabilityReportFile}, ${error}`
    );
  }
}
