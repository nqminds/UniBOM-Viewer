import fs from "fs";
import csvParser from "csv-parser";
import readline from "readline";
import path from "path";

/**
 * Mapps dependencies to cpes
 *
 *@param {string} filePath - csvFilepath
 *@param {string []} dependencies - dependencies
 */
export async function createCPEMapping(filePath, dependencies) {
  const cpeMapping = {};
  dependencies.forEach((dep) => (cpeMapping[dep] = []));

  return new Promise((resolve, reject) => {
    // use read stream to reduce memory usage.
    fs.createReadStream(filePath)
      .pipe(csvParser())
      .on("data", (row) => {
        const cpeName = row.cpe_name;
        dependencies.forEach((dep) => {
          let searchDep = dep;
          let version = "";

          // If dependency has a version, format it
          if (dep.includes("/")) {
            [searchDep, version] = dep.split("/");
            searchDep = searchDep.replace("/", ":");
            version = `:${version}`;
          }

          const regex = new RegExp(`\\b${searchDep}${version}\\b`, "i");

          if (cpeName && regex.test(cpeName)) {
            cpeMapping[dep].push(cpeName);
          }
        });
      })
      .on("end", () => resolve(cpeMapping))
      .on("error", (error) => reject(error));
  });
}

/**
 * Returns a list of dependencies
 *
 * @param {string} conanfilePath - path to conanfile.txt
 */
export async function processDependencies(conanfilePath) {
  // the file can become quite large so use ReadStream to reduce memory usage
  const fileStream = fs.createReadStream(conanfilePath);
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity,
  });

  const dependencies = [];
  let isRequiresSection = false;

  for await (const line of rl) {
    if (line.startsWith("[requires]")) {
      isRequiresSection = true;
    } else if (line.startsWith("[")) {
      isRequiresSection = false;
    } else if (isRequiresSection) {
      let dependency = line.replace("/", ":");
      dependency = dependency.replace(/'/g, "");
      if (dependency) {
        // check that the string is not empty after trimming
        dependencies.push(dependency);
      }
    }
  }
  return dependencies;
}

/**
 * Returns the path to a targetFile
 *
 * @param {path} startDirectory - Path to the start dyrectory
 * @param {string} targetFile - Name of the file
 */
export async function findFileInSubdirectories(startDirectory, targetFile) {
  const recurseDir = async (dir) => {
    const filesAndDirectories = await fs.promises.readdir(dir, {
      withFileTypes: true,
    });

    const promises = filesAndDirectories.map(async (stat) => {
      if (stat.isDirectory()) {
        return recurseDir(path.join(dir, stat.name));
      } else if (stat.name === targetFile) {
        return path.join(dir, stat.name);
      }
      return null;
    });
    const results = await Promise.all(promises);
    for (const result of results) {
      if (result) return result;
    }
    return null;
  };
  return recurseDir(startDirectory);
}
